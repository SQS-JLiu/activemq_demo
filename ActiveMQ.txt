1.在网络通讯中，HTTP请求默认是采用同步请求方式，基于请求响应模式
2.客户端与服务器通讯，调用服务端接口时，客户端必须等待服务端响应之后才能继续处理执行，这种情况属于同步方式。
3.网络通信采用同步方式的优缺点：
优点：及时响应数据给客户端，整个过程同步
缺点：可能会导致程序阻塞等待，效率比较低

思考问题：如果服务之间访问不通的情况下，如何保证数据一致性问题？
传统HTTP方式补偿（重试），存放日志表+Job定时任务

消息队列中间件是分布式系统中重要的组件，主要解决应用解耦，异步消息，流量削峰等问题，实现高性能，高可用，可伸缩和最终一致性架构。
目前使用较多的消息队列有ActiveMQ(中小型项目,Java, 主从, 万级),
RabbitMQ（大型项目, erlang, 主从, 万级）,
ZeroMQ, Kafka（日志采集, 大数据, 分布式, 十万级）,
MetaMQ, RocketMQ（阿里, 大型项目, Java, 单机万级）

点对点 ---> 一对一
一条消息只有一个消费者能收到，消费者可以随时消费队列中的消息
发布-订阅 ---> 一对多
一条消息发给多个订阅消费者，只有订阅了topic的订阅者才能收到消息

MQ需要集群部署
可控制消息的顺序
ActiveMQ默认端口61616
管理页面http: localhost:8161/admin   admin:admin

JMS消息message: 消息头 消息体 消息属性
消息头包含内容：
1)持久和非持久模式：持久即是JMS宕机后重启消息不会丢失
2)消息优先级，从0-9十个级别，0-4是普通消息，5-9是加急消息
3)MS不要求MQ严格按照这个要求, 但要求加急消息优先于普通消息,级别默认是4
4)通过设置messageID唯一识别一个消息,保证消息的幂等性，即重复发送的消息只接收一个
消息体包含内容类型：
1)TextMessage; 2)MapMessage;
3)BytesMessage; 4)StreamMessage;
5)ObjectMessage.
消息属性:
识别/去重/重点标识等操作非常有用的方法

JMS的可靠性: 持久, 事务 , 签收
1)a.非持久：messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
    非持久化:当服务器宕机, 消息不存在
  b.持久:messageProducer.setDeliveryMode(DeliveryMode.PERSISTENT);
    持久化: 当服务器宕机, 消息依然存在
JMS默认是持久化

开启事务情况下：事务权限大于签收, 事务提交就算自动签收了
             事务没提交, 签收了也无法成功签收, 会重复接收消息